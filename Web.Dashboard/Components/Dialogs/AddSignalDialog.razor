@using System.Text
@using FlircWrapper
@using Web.Dashboard.Models
@using Web.Dashboard.Services

@inject MappingService MappingService
@inject FlircService FlircService
@inject ConfigurationService ConfigService
@inject FlircDeviceManager DeviceManager
@inject CircuitAccessor CircuitAccessor
@inject ISnackbar Snackbar

@implements IDisposable

<MudDialog>
    <DialogContent>
        <div class="d-flex justify-center flex-column">
            @if (_foundProt == null)
            {
                <MudProgressCircular Color="Color.Info" Indeterminate="true" Size="Size.Large" Style="margin: 0 auto" />
                <MudText Typo="Typo.body1" Class="mt-4">
                    PRESS REMOTE BUTTON...
                </MudText>
            }
            else
            {
                <MudText Typo="Typo.body1">
                    REMOTE BUTTON RECORDED
                </MudText>
                <MudTextField
                    T="string"
                    @bind-Value="_name"
                    Immediate="true"
                    OnKeyDown="@Callback"
                    Label="Button name"
                    Variant="Variant.Outlined"
                    Margin="Margin.Dense"
                />
                <MudField Label="Buffer" Variant="Variant.Outlined" Margin="Margin.Dense">
                    @GetBufValue(_foundProt.Value)
                </MudField>
            }
        </div>
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="@Fail">Cancel</MudButton>
        <MudButton OnClick="@Submit" Disabled="BeDisabled">Add</MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter]
    IMudDialogInstance MudDialog { get; set; } = null!;

    [EditorRequired, Parameter]
    public string RemoteName { get; set; } = null!;

    private CancellationTokenSource? _cancellation;
    private Task<OperationResult<IrProt>>? _result;
    private IrProt? _foundProt;
    private string _name = string.Empty;
    private string? _circuitId;
    private bool _configModeEntered;

    private bool BeDisabled => _foundProt == null || string.IsNullOrWhiteSpace(_name);

    protected override async Task OnInitializedAsync()
    {
        // Get the real circuit ID from the scoped CircuitAccessor
        _circuitId = CircuitAccessor.CircuitId;

        if (string.IsNullOrWhiteSpace(_circuitId))
        {
            Snackbar.Add("Circuit ID not available. Please refresh and try again.", Severity.Error);
            await Fail();
            return;
        }

        if (!DeviceManager.IsConnected)
        {
            Snackbar.Add("Device not connected...", Severity.Error);
            await Fail();
            return;
        }

        // Try to enter configuration mode
        var configResult = await ConfigService.TryEnterConfigMode(_circuitId);
        if (!configResult.IsSuccess())
        {
            Snackbar.Add(string.Join(", ", configResult.ErrorMessages), Severity.Error);
            await Fail();
            return;
        }

        _configModeEntered = true;

        // Cancel any pending transmissions since we're entering config mode
        FlircService.CancelPendingTransmissions();

        if (FlircService.IsScanning)
        {
            Snackbar.Add("Someone else is currently adding a new key...", Severity.Error);
            await ExitConfigMode();
            await Fail();
            return;
        }

        _cancellation = new CancellationTokenSource();
        HandleTaskCompletion(FlircService.StartPoll(_cancellation.Token));
    }

    private void HandleTaskCompletion(Task<OperationResult<IrProt>> pollingTask)
    {
        pollingTask.ContinueWith(async t =>
        {
            if (t.IsFaulted)
            {
                await Fail();
                Snackbar.Add(t.Exception.Message, Severity.Error);
            }
            else if (t.IsCompletedSuccessfully)
            {
                // Handle successful completion
                var result = t.Result;
                if (!result.TryGetResult(out var prot))
                {
                    await Fail();
                    Snackbar.Add(string.Join(Environment.NewLine, result.ErrorMessages), Severity.Error);
                }

                _foundProt = prot;
                await InvokeAsync(StateHasChanged);
            }
        });
    }

    private async Task Callback(KeyboardEventArgs args)
    {
        if (args.Key == "Enter" && !BeDisabled)
            await Submit();
    }

    private async Task Submit()
    {
        if (!_foundProt.HasValue)
        {
            Snackbar.Add("Cannot add button if no signal has been recorded", Severity.Error);
            return;
        }

        // Create a new buffer of the correct length and convert to short[]
        var buf = _foundProt.Value.buf
            .Take(_foundProt.Value.len)
            .Select(b => unchecked((short)b))
            .ToArray();

        var result = MappingService.AddMapping(RemoteName, new MappedIr(_name, buf));

        if (result.IsSuccess())
        {
            Snackbar.Add("Button added successfully!", Severity.Success);
            await Success();
        }
        else
        {
            Snackbar.Add(string.Join(Environment.NewLine, result.ErrorMessages), Severity.Error);
        }
    }

    private static string GetBufValue(IrProt packet)
    {
        var value = new StringBuilder();
        for (var i = 0; i < packet.len && i < packet.buf.Length; i++)
        {
            value.Append($"{packet.buf[i]} ");
        }

        return value.ToString();
    }

    private async Task ExitConfigMode()
    {
        if (_configModeEntered && !string.IsNullOrWhiteSpace(_circuitId))
        {
            await ConfigService.ExitConfigMode(_circuitId);
            _configModeEntered = false;
        }
    }

    async Task Success()
    {
        await ExitConfigMode();
        await InvokeAsync(() => MudDialog.Close(DialogResult.Ok(true)));
    }

    async Task Fail()
    {
        await InvokeAsync(() => MudDialog.Cancel());
    }

    public void Dispose()
    {
        if (_cancellation is not null && _result is not null)
        {
            _cancellation.Cancel();
            _cancellation = null;
            _result = null;
        }

        // Ensure we exit config mode on dispose
        if (_configModeEntered && !string.IsNullOrWhiteSpace(_circuitId))
        {
            // Fire and forget - we're disposing
            _ = Task.Run(async () =>
            {
                try
                {
                    await ConfigService.ExitConfigMode(_circuitId);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[AddSignalDialog] Error exiting config mode on dispose: {ex.Message}");
                }
            });
        }
    }
}
